# D:/Documents/Poste_UN/Projet_Automatisation/onu_rdc_dashboard/ui/repair_write_app.R

ui_dir   <- "D:/Documents/Poste_UN/Projet_Automatisation/onu_rdc_dashboard/ui"
app_path <- file.path(ui_dir, "app.R")
run_path <- file.path(ui_dir, "run_shiny.R")

dir.create(ui_dir, showWarnings = FALSE, recursive = TRUE)

# --- 1) writer binaire sûr (CRLF) ---
write_lines_crlf <- function(lines, path){
  txt <- paste(lines, collapse = "\r\n")
  con <- file(path, open = "wb")
  on.exit(close(con), add = TRUE)
  writeBin(charToRaw(txt), con)
}

# --- 2) mini app de test (sanity check) ---
mini <- c(
  "# mini app (sanity)",
  "library(shiny)",
  "ui <- fluidPage(h1('OK mini'))",
  "server <- function(input, output, session){}",
  "shinyApp(ui, server)"
)
write_lines_crlf(mini, app_path)

# parse test
ok <- try(parse(file = app_path, encoding = "UTF-8"), silent = TRUE)
if (inherits(ok, "try-error")){
  stop("Echec d'ecriture mini app (parse). Abandon. Message: ", attr(ok, "condition")$message)
}

# --- 3) app complète (ASCII; sans pipes) ---
LINES <- c(
  "# ---- app.R (ONU RDC Dashboard - stable ASCII) ----",
  "library(shiny)",
  "library(httr2)",
  "library(jsonlite)",
  "library(readr)",
  "library(dplyr)",
  "library(DT)",
  "library(ggplot2)",
  "library(leaflet)",
  "library(sf)",
  "",
  "API_BASE <- Sys.getenv(\"ONU_API_BASE\", \"http://127.0.0.1:8000\")",
  "API_KEY  <- Sys.getenv(\"API_KEY\", \"\")",
  "",
  "str_or <- function(x, fb) {",
  "  if (!is.null(x) && is.character(x) && length(x) > 0 && nchar(x[1]) > 0) x[1] else fb",
  "}",
  "enc <- function(x) utils::URLencode(as.character(x), reserved = TRUE)",
  "",
  "qs_indicators <- function(query) {",
  "  if (!is.null(query) && nchar(query) > 0) paste0(\"?q=\", enc(query)) else \"\"",
  "}",
  "",
  "qs_export <- function(indicator_code, ref_area, source, obs_status, start, end) {",
  "  parts <- character(6); i <- 0",
  "  if (!is.null(indicator_code) && nchar(indicator_code) > 0) { i <- i + 1; parts[i] <- paste0(\"indicator_code=\", enc(indicator_code)) }",
  "  if (!is.null(ref_area)       && nchar(ref_area)       > 0) { i <- i + 1; parts[i] <- paste0(\"ref_area=\",       enc(ref_area)) }",
  "  if (!is.null(source)         && nchar(source)         > 0) { i <- i + 1; parts[i] <- paste0(\"source=\",         enc(source)) }",
  "  if (!is.null(obs_status)     && nchar(obs_status)     > 0) { i <- i + 1; parts[i] <- paste0(\"obs_status=\",     enc(obs_status)) }",
  "  if (!is.null(start)          && !is.na(start))              { i <- i + 1; parts[i] <- paste0(\"start=\",          enc(start)) }",
  "  if (!is.null(end)            && !is.na(end))                { i <- i + 1; parts[i] <- paste0(\"end=\",            enc(end)) }",
  "  if (i == 0) \"\" else paste0(\"?\", paste(parts[seq_len(i)], collapse = \"&\"))",
  "}",
  "",
  "api_get_text <- function(endpoint_with_qs, timeout = 30) {",
  "  u <- paste0(API_BASE, endpoint_with_qs)",
  "  req <- httr2::request(u)",
  "  if (nzchar(API_KEY)) req <- httr2::req_headers(req, \"X-API-Key\" = API_KEY)",
  "  req <- httr2::req_timeout(req, timeout)",
  "  resp <- httr2::req_perform(req)",
  "  st <- httr2::resp_status(resp)",
  "  if (is.na(st) || st >= 400) stop(\"HTTP error: \", st)",
  "  rawToChar(httr2::resp_body_raw(resp))",
  "}",
  "",
  "api_get_csv <- function(endpoint_with_qs, timeout = 60) {",
  "  txt <- api_get_text(endpoint_with_qs, timeout = timeout)",
  "  readr::read_csv(I(txt), show_col_types = FALSE)",
  "}",
  "",
  "safe_fromJSON <- function(txt) {",
  "  out <- NULL; try(out <- jsonlite::fromJSON(txt), silent = TRUE); if (is.null(out)) NULL else out",
  "}",
  "",
  "load_indicators <- function(query = \"\") {",
  "  qs <- qs_indicators(query)",
  "  txt <- api_get_text(paste0(\"/indicators\", qs), timeout = 30)",
  "  obj <- safe_fromJSON(txt)",
  "  if (is.null(obj)) tibble(indicator_code = character(0), indicator_name = character(0)) else",
  "    tibble::as_tibble(obj) %>% mutate(across(everything(), as.character)) %>% arrange(indicator_code)",
  "}",
  "",
  "fetch_values <- function(ind_code = NULL, ref_area = NULL, source = NULL, obs = NULL, start = NA_real_, end = NA_real_) {",
  "  qs <- qs_export(ind_code, ref_area, source, obs, start, end)",
  "  api_get_csv(paste0(\"/export/csv\", qs), timeout = 60)",
  "}",
  "",
  "ui <- fluidPage(",
  "  titlePanel(\"ONU RDC - Indicateurs\"),",
  "  sidebarLayout(",
  "    sidebarPanel(",
  "      selectizeInput(\"ind_name\", \"Indicateur (nom)\", choices = NULL, multiple = FALSE,",
  "                     options = list(placeholder = \"Tapez quelques lettres...\")),",
  "      selectizeInput(\"ind_code\", \"Code indicateur\", choices = NULL, multiple = FALSE),",
  "      selectizeInput(\"ref_area\", \"Zone/pays (ISO3)\", choices = NULL, multiple = FALSE),",
  "      selectizeInput(\"source\",   \"Source\",           choices = NULL, multiple = FALSE),",
  "      selectizeInput(\"obs\",      \"Statut d'observation\", choices = c(\"\" = \"\", \"TRUE\" = \"TRUE\", \"FALSE\" = \"FALSE\"), multiple = FALSE),",
  "      sliderInput(\"years\", \"Periode\", min = 1990, max = 2030, value = c(2000, 2025), sep = \"\"),",
  "      actionButton(\"go\", \"Appliquer\"),",
  "      tags$hr(),",
  "      downloadButton(\"dl_csv\",  \"Telecharger CSV\"),",
  "      downloadButton(\"dl_xlsx\", \"Telecharger XLSX\"),",
  "      tags$hr(),",
  "      tags$small(strong(\"API_BASE: \"), code(API_BASE), tags$br(), strong(\"API_KEY definie ? \"), code(nzchar(API_KEY)))",
  "    ),",
  "    mainPanel(",
  "      tabsetPanel(",
  "        id = \"tabs\",",
  "        tabPanel(\"Tableau\", h4(textOutput(\"subtitle\")), DTOutput(\"tbl\")),",
  "        tabPanel(\"Graphique\",",
  "                 fluidRow(",
  "                   column(6, selectInput(\"chart_group\", \"Couleur par...\", choices = c(\"ref_area\",\"source\"), selected = \"ref_area\")),",
  "                   column(6, checkboxInput(\"chart_points\", \"Afficher les points\", TRUE))",
  "                 ),",
  "                 plotOutput(\"ts_plot\", height = \"420px\")),",
  "        tabPanel(\"Carte\",",
  "                 fluidRow(column(6, uiOutput(\"map_year_ui\")), column(6, helpText(\"Carte par code ISO3 (ref_area).\"))),",
  "                 leafletOutput(\"map\", height = \"520px\"))",
  "      )",
  "    )",
  "  )",
  ")",
  "",
  "server <- function(input, output, session){",
  "  observe({ try(api_get_text(\"/health\"), silent = TRUE) })",
  "",
  "  indicators <- reactiveVal(tibble(indicator_code = character(0), indicator_name = character(0)))",
  "  observeEvent(TRUE, {",
  "    inds <- load_indicators(\"\")",
  "    indicators(inds)",
  "    if (nrow(inds) > 0) {",
  "      updateSelectizeInput(session, \"ind_name\", choices = sort(unique(inds$indicator_name)), server = TRUE)",
  "      updateSelectizeInput(session, \"ind_code\", choices = inds$indicator_code, server = TRUE)",
  "    }",
  "  }, once = TRUE)",
  "",
  "  observeEvent(input$ind_name, {",
  "    inds <- indicators(); if (nrow(inds) == 0) return(NULL)",
  "    sel <- inds[inds$indicator_name == input$ind_name, , drop = FALSE]",
  "    if (nrow(sel) >= 1) updateSelectizeInput(session, \"ind_code\", selected = sel$indicator_code[1])",
  "  })",
  "",
  "  observeEvent(input$ind_code, {",
  "    inds <- indicators(); if (nrow(inds) == 0) return(NULL)",
  "    sel <- inds[inds$indicator_code == input$ind_code, , drop = FALSE]",
  "    if (nrow(sel) >= 1) updateSelectizeInput(session, \"ind_name\", selected = sel$indicator_name[1])",
  "  })",
  "",
  "  observeEvent(input$ind_code, {",
  "    if (!nzchar(input$ind_code)) return(NULL)",
  "    dat <- fetch_values(ind_code = input$ind_code)",
  "    if (!is.data.frame(dat) || nrow(dat) == 0) return(NULL)",
  "    y <- suppressWarnings(as.numeric(dat$period))",
  "    yr_min <- suppressWarnings(min(y, na.rm = TRUE)); if (!is.finite(yr_min)) yr_min <- 1990",
  "    yr_max <- suppressWarnings(max(y, na.rm = TRUE)); if (!is.finite(yr_max)) yr_max <- 2030",
  "    updateSliderInput(session, \"years\", min = floor(yr_min), max = ceiling(yr_max), value = c(max(yr_min,2000), min(yr_max,2025)))",
  "    ra <- sort(unique(na.omit(as.character(dat$ref_area))))",
  "    sel_ra <- NULL",
  "    if (length(ra) > 0) {",
  "      if (any(ra == \"COD\")) sel_ra <- \"COD\"",
  "    }",
  "    updateSelectizeInput(session, \"ref_area\", choices = ra, selected = sel_ra, server = TRUE)",
  "    src <- sort(unique(na.omit(as.character(dat$source))))",
  "    updateSelectizeInput(session, \"source\", choices = src, server = TRUE)",
  "    has_true  <- any(dat$obs_status %in% TRUE,  na.rm = TRUE)",
  "    has_false <- any(dat$obs_status %in% FALSE, na.rm = TRUE)",
  "    obs_choices <- c(\"\" = \"\")",
  "    if (isTRUE(has_true))  obs_choices <- c(obs_choices, \"TRUE\" = \"TRUE\")",
  "    if (isTRUE(has_false)) obs_choices <- c(obs_choices, \"FALSE\" = \"FALSE\")",
  "    updateSelectizeInput(session, \"obs\", choices = obs_choices, selected = \"\")",
  "  }, ignoreInit = TRUE)",
  "",
  "  dat_filtered_core <- reactive({",
  "    if (!nzchar(input$ind_code)) return(tibble())",
  "    p_ref <- if (nzchar(input$ref_area)) input$ref_area else NULL",
  "    p_src <- if (nzchar(input$source))   input$source   else NULL",
  "    p_obs <- if (nzchar(input$obs))      input$obs      else NULL",
  "    out <- fetch_values(input$ind_code, p_ref, p_src, p_obs, input$years[1], input$years[2])",
  "    if (!is.data.frame(out) || nrow(out) == 0) return(tibble())",
  "    out$period  <- suppressWarnings(as.numeric(out$period))",
  "    out$value   <- suppressWarnings(as.numeric(out$value))",
  "    out$ref_area <- toupper(as.character(out$ref_area))",
  "    out$indicator_name <- as.character(out$indicator_name)",
  "    out$source  <- as.character(out$source)",
  "    out[order(out$ref_area, out$period), , drop = FALSE]",
  "  })",
  "  dat_filtered <- isolate(dat_filtered_core) %>% bindEvent(input$go, ignoreInit = TRUE)",
  "",
  "  output$subtitle <- renderText({",
  "    paste0(\"Resultats pour \", str_or(input$ind_code, \"-\"), \" - \", str_or(input$ref_area, \"Toutes zones\"), \" (\", input$years[1], \"-\", input$years[2], \")\")",
  "  })",
  "",
  "  output$tbl <- renderDT({",
  "    dat <- dat_filtered()",
  "    DT::datatable(dat, options = list(pageLength = 10, scrollX = TRUE))",
  "  })",
  "",
  "  output$ts_plot <- renderPlot({",
  "    dat <- dat_filtered(); if (!is.data.frame(dat) || nrow(dat) == 0) return(invisible(NULL))",
  "    grp <- str_or(input$chart_group, \"ref_area\")",
  "    if (!(grp %in% names(dat))) grp <- \"ref_area\"",
  "    g <- ggplot(dat, aes_string(x = \"period\", y = \"value\", color = grp, group = grp)) +",
  "      geom_line(na.rm = TRUE) +",
  "      labs(x = \"Annee\", y = \"Valeur\", color = grp,",
  "           title = paste0(str_or(unique(na.omit(dat$indicator_name))[1], \"\"), \" (\", input$ind_code, \")\")) +",
  "      theme_minimal(base_size = 12)",
  "    if (isTRUE(input$chart_points)) g <- g + geom_point(size = 1.5, na.rm = TRUE)",
  "    g",
  "  })",
  "",
  "  output$map_year_ui <- renderUI({",
  "    dat <- dat_filtered(); if (!is.data.frame(dat) || nrow(dat) == 0) return(NULL)",
  "    yrs <- sort(unique(na.omit(as.integer(dat$period))))",
  "    selectInput(\"map_year\", \"Annee pour la carte\", choices = yrs, selected = max(yrs))",
  "  })",
  "",
  "  world_sf <- reactiveVal(NULL)",
  "  observeEvent(TRUE, {",
  "    need_ne <- (!requireNamespace(\"rnaturalearth\", quietly = TRUE) || !requireNamespace(\"rnaturalearthdata\", quietly = TRUE))",
  "    if (need_ne) { install.packages(\"rnaturalearth\"); install.packages(\"rnaturalearthdata\") }",
  "    w <- rnaturalearth::ne_countries(scale = \"medium\", returnclass = \"sf\")",
  "    w <- sf::st_transform(w, 4326)",
  "    w <- dplyr::select(w, iso_a3, name_long, geometry)",
  "    world_sf(w)",
  "  }, once = TRUE)",
  "",
  "  output$map <- renderLeaflet({",
  "    dat <- dat_filtered(); if (!is.data.frame(dat) || nrow(dat) == 0) return(invisible(NULL))",
  "    w <- world_sf(); if (is.null(w)) return(invisible(NULL))",
  "    yr <- input$map_year",
  "    dat2 <- dat[round(dat$period) == as.integer(yr), , drop = FALSE]",
  "    if (nrow(dat2) == 0) {",
  "      m <- leaflet();",
  "      m <- addTiles(m);",
  "      return(m)",
  "    }",
  "    agg <- suppressWarnings(dat2 %>% dplyr::group_by(ref_area) %>% dplyr::summarise(value = mean(value, na.rm = TRUE), .groups = \"drop\"))",
  "    shp <- dplyr::left_join(w, agg, by = c(\"iso_a3\" = \"ref_area\"))",
  "    pal <- colorNumeric(\"YlGnBu\", domain = shp$value, na.color = \"#cccccc\")",
  "    m <- leaflet(shp, options = leafletOptions(minZoom = 1, worldCopyJump = TRUE))",
  "    m <- addTiles(m)",
  "    m <- addPolygons(",
  "      m,",
  "      fillColor = ~pal(value), weight = 0.6, opacity = 1, color = \"white\",",
  "      dashArray = \"3\", fillOpacity = 0.8,",
  "      highlight = highlightOptions(weight = 2, color = \"#666\", dashArray = \"\", fillOpacity = 0.85, bringToFront = TRUE),",
  "      label = ~htmltools::HTML(sprintf(\"%s (%s)<br/>Valeur: %s\", name_long, iso_a3, ifelse(is.finite(value), as.character(round(value, 2)), \"NA\")))",
  "    )",
  "    m <- addLegend(m, \"bottomright\", pal = pal, values = ~value, title = paste0(str_or(input$ind_code, \"\"), \" - \", yr))",
  "    m",
  "  })",
  "",
  "  output$dl_csv <- downloadHandler(",
  "    filename = function() {",
  "      fname <- paste0(str_or(input$ind_code, \"export\"), \"_\", str_or(input$ref_area, \"ALL\"), \"_\", input$years[1], \"-\", input$years[2], \".csv\")",
  "      fname",
  "    },",
  "    content = function(file) {",
  "      qs <- qs_export(input$ind_code, input$ref_area, NULL, NULL, input$years[1], input$years[2])",
  "      raw <- charToRaw(api_get_text(paste0(\"/export/csv\", qs), timeout = 60))",
  "      writeBin(raw, file)",
  "    }",
  "  )",
  "",
  "  output$dl_xlsx <- downloadHandler(",
  "    filename = function() {",
  "      fname <- paste0(str_or(input$ind_code, \"export\"), \"_\", str_or(input$ref_area, \"ALL\"), \"_\", input$years[1], \"-\", input$years[2], \".xlsx\")",
  "      fname",
  "    },",
  "    content = function(file) {",
  "      qs <- qs_export(input$ind_code, input$ref_area, NULL, NULL, input$years[1], input$years[2])",
  "      req <- httr2::request(paste0(API_BASE, \"/export/xlsx\", qs))",
  "      if (nzchar(API_KEY)) req <- httr2::req_headers(req, \"X-API-Key\" = API_KEY)",
  "      req <- httr2::req_timeout(req, 60)",
  "      resp <- httr2::req_perform(req)",
  "      if (httr2::resp_status(resp) >= 400) stop(\"HTTP error XLSX\")",
  "      writeBin(httr2::resp_body_raw(resp), file)",
  "    }",
  "  )",
  "}",
  "",
  "shinyApp(ui, server)",
  ""
)

write_lines_crlf(LINES, app_path)

# --- 4) parse final ---
ok2 <- try(parse(file = app_path, encoding = "UTF-8"), silent = TRUE)
if (inherits(ok2, "try-error")){
  # si erreur, montrer la ligne fautive
  txt <- readLines(app_path, warn = FALSE, encoding = "UTF-8")
  for(i in seq_along(txt)){
    ok3 <- try(parse(text = txt[1:i]), silent = TRUE)
    if(inherits(ok3, "try-error")){
      cat("Parse ERROR ligne:", i, "\n>>", txt[i], "\nMessage:", attr(ok3, "condition")$message, "\n")
      stop("Parse final echoue. Voir ligne ci-dessus.")
    }
  }
} else {
  cat("OK: app.R ecrit et parse sans erreur.\n")
}
